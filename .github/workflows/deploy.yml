name: Deploy to Production

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  # SSH Connection
  SSH_HOST: ${{ secrets.SSH_HOST }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
  
  # Production Database
  DB_NAME: ${{ secrets.DB_NAME }}
  DB_USER: ${{ secrets.DB_USER }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  
  # Domain
  DOMAIN: ${{ secrets.DOMAIN }}
  
  # Test Database Configuration
  TEST_DB_NAME: ${{ secrets.TEST_DB_NAME }}
  TEST_DB_USER: ${{ secrets.TEST_DB_USER }}
  TEST_DB_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
  
  # PostgreSQL Default Database (for administrative operations)
  POSTGRES_DEFAULT_DB: ${{ secrets.POSTGRES_DEFAULT_DB }}

jobs:
  lint:
    name: ğŸ” Lint Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: ğŸ“¦ Install dependencies
        run: npm ci

      - name: ğŸ” Run lint
        timeout-minutes: 5
        run: npm run lint:check

  test-unit:
    name: ğŸ§ª Unit Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: ğŸ“¦ Install dependencies
        run: npm ci

      - name: ğŸ§ª Run unit tests with coverage
        timeout-minutes: 10
        env:
          NODE_ENV: test
        run: npm run test:unit -- --coverage --coverageDirectory=coverage/unit --coverageReporters=lcov --coverageReporters=text --coverageReporters=text-summary

      - name: ğŸ“Š Upload unit test coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-coverage
          path: coverage/unit
          retention-days: 7

  security-scan:
    name: ğŸ”’ Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: ğŸ“¦ Install dependencies
        run: npm ci

      - name: ğŸ”’ Run npm audit
        timeout-minutes: 5
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”’ Running npm audit..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          npm audit --audit-level=moderate || true
          echo "âœ… Security scan completed"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  setup-test-database:
    name: ğŸ“¦ Setup Test Database
    runs-on: ubuntu-latest
    needs: [test-unit, security-scan]
    timeout-minutes: 10
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: ${{ secrets.TEST_DB_USER }}
          POSTGRES_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          POSTGRES_DB: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: ğŸ’¾ Cache apt packages
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: apt-${{ runner.os }}-postgresql-client
          restore-keys: |
            apt-${{ runner.os }}-

      - name: ğŸ“¥ Install PostgreSQL client
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends postgresql-client

      - name: ğŸ” Verify PostgreSQL service
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: ${{ secrets.TEST_DB_USER }}
          PGPASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ” Verifying PostgreSQL service..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          MAX_RETRIES=30
          RETRY_COUNT=0
          until pg_isready -h localhost -p 5432 -U ${{ secrets.TEST_DB_USER }}; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
              echo "âŒ PostgreSQL service did not become ready"
              exit 1
            fi
            echo "   Attempt $RETRY_COUNT/$MAX_RETRIES: Waiting for PostgreSQL..."
            sleep 2
          done
          echo "âœ… PostgreSQL service is ready"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: ğŸ†• Create test database
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: ${{ secrets.TEST_DB_USER }}
          PGPASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          TEST_DB_NAME: ${{ secrets.TEST_DB_NAME }}
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ†• Creating test database..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          psql -h localhost -p 5432 -U ${{ secrets.TEST_DB_USER }} -c "CREATE DATABASE $TEST_DB_NAME;" 2>&1 || echo "âš ï¸ Database may already exist (OK)"
          echo "âœ… Test database '$TEST_DB_NAME' created"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: âœ… Verify test database
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: ${{ secrets.TEST_DB_USER }}
          PGPASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          TEST_DB_NAME: ${{ secrets.TEST_DB_NAME }}
        run: |
          if psql -h localhost -p 5432 -U ${{ secrets.TEST_DB_USER }} -lqt | cut -d \| -f 1 | grep -qw "$TEST_DB_NAME"; then
            echo "âœ… Test database '$TEST_DB_NAME' verified"
          else
            echo "âŒ Test database '$TEST_DB_NAME' not found"
            exit 1
          fi

  test-integration:
    name: ğŸ”— Integration Tests
    runs-on: ubuntu-latest
    needs: setup-test-database
    timeout-minutes: 20
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: ${{ secrets.TEST_DB_USER }}
          POSTGRES_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          POSTGRES_DB: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: ğŸ“¦ Install dependencies
        run: npm ci

      - name: ğŸ’¾ Cache apt packages
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: apt-${{ runner.os }}-postgresql-client
          restore-keys: |
            apt-${{ runner.os }}-

      - name: ğŸ“¥ Install PostgreSQL client
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends postgresql-client

      - name: ğŸ” Wait for PostgreSQL
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: ${{ secrets.TEST_DB_USER }}
          PGPASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
        run: |
          until pg_isready -h localhost -p 5432 -U ${{ secrets.TEST_DB_USER }}; do
            echo "â³ Waiting for PostgreSQL..."
            sleep 2
          done
          echo "âœ… PostgreSQL is ready"

      - name: ğŸ†• Create test database if not exists
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: ${{ secrets.TEST_DB_USER }}
          PGPASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          TEST_DB_NAME: ${{ secrets.TEST_DB_NAME }}
        run: |
          if ! psql -h localhost -p 5432 -U ${{ secrets.TEST_DB_USER }} -lqt | cut -d \| -f 1 | grep -qw "$TEST_DB_NAME"; then
            echo "ğŸ“¦ Creating test database '$TEST_DB_NAME'..."
            psql -h localhost -p 5432 -U ${{ secrets.TEST_DB_USER }} -c "CREATE DATABASE $TEST_DB_NAME;" || echo "âš ï¸ Database creation failed"
          else
            echo "âœ… Test database '$TEST_DB_NAME' already exists"
          fi

      - name: ğŸ”„ Run migrations
        env:
          NODE_ENV: test
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: ${{ secrets.TEST_DB_USER }}
          DB_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          DB_NAME: ${{ secrets.TEST_DB_NAME }}
        run: |
          echo "ğŸ”„ Running database migrations..."
          npm run migrate
          echo "âœ… Migrations completed"

      - name: ğŸ§ª Run integration tests with retry
        timeout-minutes: 15
        env:
          NODE_ENV: test
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: ${{ secrets.TEST_DB_USER }}
          DB_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          DB_NAME: ${{ secrets.TEST_DB_NAME }}
          REDIS_HOST: localhost
          REDIS_PORT: 6379
        run: |
          echo "ğŸ§ª Running integration tests..."
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if npm run test:integration; then
              echo "âœ… Integration tests passed"
              exit 0
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "âš ï¸ Integration tests failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
              sleep 5
            fi
          done
          echo "âŒ Integration tests failed after $MAX_RETRIES attempts"
          exit 1

      - name: ğŸ“Š Upload integration test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: |
            coverage/
            test-results/
          retention-days: 7

  test-e2e:
    name: ğŸ­ E2E Tests
    runs-on: ubuntu-latest
    needs: setup-test-database
    timeout-minutes: 20
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: ${{ secrets.TEST_DB_USER }}
          POSTGRES_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          POSTGRES_DB: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: ğŸ“¦ Install dependencies
        run: npm ci

      - name: ğŸ’¾ Cache apt packages
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: apt-${{ runner.os }}-postgresql-client
          restore-keys: |
            apt-${{ runner.os }}-

      - name: ğŸ“¥ Install PostgreSQL client
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends postgresql-client

      - name: ğŸ” Wait for PostgreSQL
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: ${{ secrets.TEST_DB_USER }}
          PGPASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
        run: |
          until pg_isready -h localhost -p 5432 -U ${{ secrets.TEST_DB_USER }}; do
            echo "â³ Waiting for PostgreSQL..."
            sleep 2
          done
          echo "âœ… PostgreSQL is ready"

      - name: ğŸ†• Create test database if not exists
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: ${{ secrets.TEST_DB_USER }}
          PGPASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          TEST_DB_NAME: ${{ secrets.TEST_DB_NAME }}
        run: |
          if ! psql -h localhost -p 5432 -U ${{ secrets.TEST_DB_USER }} -lqt | cut -d \| -f 1 | grep -qw "$TEST_DB_NAME"; then
            echo "ğŸ“¦ Creating test database '$TEST_DB_NAME'..."
            psql -h localhost -p 5432 -U ${{ secrets.TEST_DB_USER }} -c "CREATE DATABASE $TEST_DB_NAME;" || echo "âš ï¸ Database creation failed"
          else
            echo "âœ… Test database '$TEST_DB_NAME' already exists"
          fi

      - name: ğŸ”„ Run migrations
        timeout-minutes: 5
        env:
          NODE_ENV: test
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: ${{ secrets.TEST_DB_USER }}
          DB_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          DB_NAME: ${{ secrets.TEST_DB_NAME }}
        run: |
          echo "ğŸ”„ Running database migrations..."
          npm run migrate
          echo "âœ… Migrations completed"

      - name: ğŸ­ Run E2E tests with retry
        timeout-minutes: 15
        env:
          NODE_ENV: test
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: ${{ secrets.TEST_DB_USER }}
          DB_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          DB_NAME: ${{ secrets.TEST_DB_NAME }}
          REDIS_HOST: localhost
          REDIS_PORT: 6379
        run: |
          echo "ğŸ­ Running E2E tests..."
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if npm run test:e2e; then
              echo "âœ… E2E tests passed"
              exit 0
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "âš ï¸ E2E tests failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
              sleep 5
            fi
          done
          echo "âŒ E2E tests failed after $MAX_RETRIES attempts"
          exit 1

      - name: ğŸ“Š Upload E2E test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results
          path: |
            coverage/
            test-results/
          retention-days: 7

  cleanup-test-database:
    name: ğŸ—‘ï¸ Cleanup Test Database
    runs-on: ubuntu-latest
    needs: [setup-test-database, test-integration, test-e2e]
    if: always()
    timeout-minutes: 5
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: ${{ secrets.TEST_DB_USER }}
          POSTGRES_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          POSTGRES_DB: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: ğŸ’¾ Cache apt packages
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: apt-${{ runner.os }}-postgresql-client
          restore-keys: |
            apt-${{ runner.os }}-

      - name: ğŸ“¥ Install PostgreSQL client
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends postgresql-client

      - name: ğŸ” Wait for PostgreSQL
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: ${{ secrets.TEST_DB_USER }}
          PGPASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
        run: |
          MAX_RETRIES=30
          RETRY_COUNT=0
          until pg_isready -h localhost -p 5432 -U ${{ secrets.TEST_DB_USER }}; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
              echo "âŒ PostgreSQL service did not become ready"
              exit 1
            fi
            sleep 2
          done
          echo "âœ… PostgreSQL service is ready"

      - name: ğŸ—‘ï¸ Drop test database
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: ${{ secrets.TEST_DB_USER }}
          PGPASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          TEST_DB_NAME: ${{ secrets.TEST_DB_NAME }}
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ—‘ï¸ Cleaning up test database..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          psql -h localhost -p 5432 -U ${{ secrets.TEST_DB_USER }} -c "DROP DATABASE IF EXISTS $TEST_DB_NAME;" 2>&1 || echo "âš ï¸ Database may not exist (OK)"
          echo "âœ… Test database cleanup completed"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  generate-coverage-report:
    name: ğŸ“Š Generate Coverage Report
    runs-on: ubuntu-latest
    needs: [test-unit, test-integration, test-e2e]
    if: always()
    timeout-minutes: 5
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¥ Download unit test coverage
        uses: actions/download-artifact@v4
        with:
          name: unit-test-coverage
          path: coverage/unit

      - name: ğŸ“¥ Download integration test results
        uses: actions/download-artifact@v4
        with:
          name: integration-test-results
          path: coverage/integration
          continue-on-error: true

      - name: ğŸ“¥ Download E2E test results
        uses: actions/download-artifact@v4
        with:
          name: e2e-test-results
          path: coverage/e2e
          continue-on-error: true

      - name: ğŸ“Š Generate combined coverage report
        run: |
          echo "ğŸ“Š Generating coverage report..."
          if [ -d "coverage/unit" ]; then
            echo "âœ… Unit test coverage found"
          fi
          echo "ğŸ“Š Coverage report generation completed"

      - name: ğŸ“Š Upload coverage to Codecov
        if: always()
        uses: codecov/codecov-action@v4
        continue-on-error: true
        with:
          files: ./coverage/unit/lcov.info
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: ğŸ“Š Comment PR with coverage
        if: github.event_name == 'pull_request'
        uses: py-cov-action/python-coverage-comment-action@v3
        continue-on-error: true
        with:
          GITHUB_TOKEN: ${{ github.token }}
          COVERAGE_LABEL: 'coverage'
          MINIMUM_GREEN: 80
          MINIMUM_ORANGE: 70

  setup:
    name: ğŸ”Œ Setup SSH Connection
    runs-on: ubuntu-latest
    needs: cleanup-test-database
    timeout-minutes: 10
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: ğŸ’¾ Cache apt packages
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: apt-${{ runner.os }}-sshpass
          restore-keys: |
            apt-${{ runner.os }}-

      - name: ğŸ“¥ Install SSH tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends sshpass

      - name: ğŸ” Test SSH connection
        run: |
          echo "::add-mask::$SSH_PASSWORD"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ” Testing SSH connection..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          if sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o ConnectTimeout=10 \
            $SSH_USER@$SSH_HOST "echo 'âœ… SSH connection successful' && hostname"; then
            echo "âœ… SSH connection established"
          else
            echo "âŒ SSH connection failed"
            exit 1
          fi
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  backup:
    name: ğŸ’¾ Backup Database
    runs-on: ubuntu-latest
    needs: setup
    timeout-minutes: 10
    
    steps:
      - name: ğŸ’¾ Cache apt packages
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: apt-${{ runner.os }}-sshpass
          restore-keys: |
            apt-${{ runner.os }}-

      - name: ğŸ“¥ Install SSH tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends sshpass

      - name: ğŸ’¾ Create database backup
        run: |
          echo "::add-mask::$SSH_PASSWORD"
          echo "::add-mask::$DB_PASSWORD"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ’¾ Creating database backup..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST "DB_NAME='$DB_NAME' DB_USER='$DB_USER' POSTGRES_DEFAULT_DB='$POSTGRES_DEFAULT_DB' bash -s" << 'ENDSSH'
            if docker ps --format '{{.Names}}' | grep -q 'transaction-db'; then
              echo "âœ… PostgreSQL container is running"
              
              BACKUP_DIR="/tmp/backups"
              mkdir -p "$BACKUP_DIR"
              TIMESTAMP=$(date +%Y%m%d_%H%M%S)
              BACKUP_FILE="$BACKUP_DIR/${DB_NAME}_${TIMESTAMP}.sql"
              
              echo "ğŸ’¾ Creating backup: $BACKUP_FILE"
              docker exec transaction-db pg_dump -U "$DB_USER" -d "$DB_NAME" > "$BACKUP_FILE" 2>&1 || echo "âš ï¸ Backup may have failed (OK for first deployment)"
              
              if [ -f "$BACKUP_FILE" ] && [ -s "$BACKUP_FILE" ]; then
                BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
                echo "âœ… Backup created: $BACKUP_SIZE"
              fi
              
              echo "ğŸ§¹ Cleaning up old backups (keeping last 5)..."
              BACKUP_COUNT=$(ls -1 "$BACKUP_DIR/${DB_NAME}"_*.sql 2>/dev/null | wc -l)
              if [ "$BACKUP_COUNT" -gt 5 ]; then
                cd "$BACKUP_DIR"
                ls -t "${DB_NAME}"_*.sql 2>/dev/null | tail -n +6 | xargs rm -f || true
                echo "âœ… Old backups removed"
              fi
            else
              echo "â„¹ï¸ PostgreSQL container not running (OK for first deployment)"
            fi
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          ENDSSH

  prepare-deployment:
    name: ğŸ“¦ Prepare Deployment
    runs-on: ubuntu-latest
    needs: backup
    timeout-minutes: 10
    
    steps:
      - name: ğŸ’¾ Cache apt packages
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: apt-${{ runner.os }}-sshpass
          restore-keys: |
            apt-${{ runner.os }}-

      - name: ğŸ“¥ Install SSH tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends sshpass

      - name: ğŸ“¥ Clone repository and create archive
        env:
          REPO_URL: https://github.com/${{ github.repository }}.git
        run: |
          echo "::add-mask::$SSH_PASSWORD"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“¦ Preparing deployment..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST << ENDSSH
            echo "ğŸ“¥ Cloning repository..."
            mkdir -p /tmp
            cd /tmp
            rm -rf transaction-processor-api
            git clone $REPO_URL transaction-processor-api
            cd transaction-processor-api
            
            echo "ğŸ“¦ Creating application archive..."
            tar -czf app.tar.gz \
              --exclude='node_modules' --exclude='dist' --exclude='build' \
              --exclude='test' --exclude='coverage' --exclude='*.spec.ts' \
              --exclude='.git' --exclude='docker' --exclude='*.md' \
              src/ package*.json tsconfig*.json nest-cli.json migrations/ \
              eslint.config.mjs .prettierrc 2>&1
            
            echo "âœ… Archive created: $(du -h app.tar.gz | cut -f1)"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          ENDSSH

  build-and-deploy:
    name: ğŸš€ Build and Deploy
    runs-on: ubuntu-latest
    needs: prepare-deployment
    timeout-minutes: 30
    
    steps:
      - name: ğŸ’¾ Cache apt packages
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: apt-${{ runner.os }}-sshpass
          restore-keys: |
            apt-${{ runner.os }}-

      - name: ğŸ“¥ Install SSH tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends sshpass

      - name: ğŸš€ Build and deploy containers
        run: |
          echo "::add-mask::$SSH_PASSWORD"
          echo "::add-mask::$DB_PASSWORD"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸš€ Building and deploying containers..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST "DB_NAME='$DB_NAME' DB_USER='$DB_USER' DB_PASSWORD='$DB_PASSWORD' bash -s" << 'ENDSSH'
            cd /tmp/transaction-processor-api/docker
            
            echo "ğŸ›‘ Stopping existing containers..."
            docker compose down -v || true
            docker container prune -f || true
            docker volume prune -f || true
            
            echo "ğŸ”¨ Building containers..."
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1
            docker compose pull || true
            docker compose build --pull --progress=plain
            
            echo "ğŸš€ Starting containers..."
            docker compose up -d
            
            echo "â³ Waiting for services to initialize..."
            sleep 15
            
            cd /tmp/transaction-processor-api
            rm -f app.tar.gz || true
            
            echo "ğŸ“Š Container status:"
            docker compose ps
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          ENDSSH

  wait-services:
    name: â³ Wait Services and Restore Backup
    runs-on: ubuntu-latest
    needs: build-and-deploy
    timeout-minutes: 15
    
    steps:
      - name: ğŸ’¾ Cache apt packages
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: apt-${{ runner.os }}-sshpass
          restore-keys: |
            apt-${{ runner.os }}-

      - name: ğŸ“¥ Install SSH tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends sshpass

      - name: â³ Wait for services and restore backup
        run: |
          echo "::add-mask::$SSH_PASSWORD"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "â³ Waiting for services and restoring backup..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST "DB_NAME='$DB_NAME' DB_USER='$DB_USER' POSTGRES_DEFAULT_DB='$POSTGRES_DEFAULT_DB' bash -s" << 'ENDSSH'
            echo "â³ Waiting for PostgreSQL..."
            timeout=60
            elapsed=0
            while [ $elapsed -lt $timeout ]; do
              if docker exec transaction-db pg_isready -U "$DB_USER" > /dev/null 2>&1; then
                echo "âœ… PostgreSQL is ready"
                break
              fi
              sleep 2
              elapsed=$((elapsed + 2))
            done
            
            echo "ğŸ“¥ Restoring backup if available..."
            BACKUP_DIR="/tmp/backups"
            LATEST_BACKUP=$(ls -t "$BACKUP_DIR/${DB_NAME}"_*.sql 2>/dev/null | head -1)
            if [ -n "$LATEST_BACKUP" ] && [ -f "$LATEST_BACKUP" ]; then
              docker exec -i transaction-db psql -U "$DB_USER" -d "$POSTGRES_DEFAULT_DB" -c "DROP DATABASE IF EXISTS $DB_NAME;" || true
              docker exec -i transaction-db psql -U "$DB_USER" -d "$POSTGRES_DEFAULT_DB" -c "CREATE DATABASE $DB_NAME;" || true
              cat "$LATEST_BACKUP" | docker exec -i transaction-db psql -U "$DB_USER" -d "$DB_NAME" || echo "âš ï¸ Backup restore failed (OK for first deployment)"
            fi
            
            echo "â³ Waiting for application..."
            elapsed=0
            while [ $elapsed -lt $timeout ]; do
              if docker ps --format '{{.Names}}' | grep -q 'transaction-api' && \
                 docker exec transaction-api node -e "console.log('OK')" > /dev/null 2>&1; then
                echo "âœ… Application is ready"
                break
              fi
              sleep 2
              elapsed=$((elapsed + 2))
            done
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          ENDSSH

  finalize-deployment:
    name: ğŸ”„ Finalize Deployment
    runs-on: ubuntu-latest
    needs: wait-services
    timeout-minutes: 10
    
    steps:
      - name: ğŸ’¾ Cache apt packages
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: apt-${{ runner.os }}-sshpass
          restore-keys: |
            apt-${{ runner.os }}-

      - name: ğŸ“¥ Install SSH tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends sshpass

      - name: ğŸ”„ Run migrations and verify
        run: |
          echo "::add-mask::$SSH_PASSWORD"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”„ Finalizing deployment..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST << 'ENDSSH'
            echo "ğŸ”„ Running database migrations..."
            docker exec transaction-api npm run migrate || echo "âš ï¸ Migrations may have already been applied"
            
            echo "ğŸ“Š Deployment status:"
            cd /tmp/transaction-processor-api/docker
            docker compose ps
            echo ""
            echo "ğŸ“‹ Application logs (last 20 lines):"
            docker compose logs --tail=20 transaction-api || true
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          ENDSSH

  verify:
    name: âœ… Verify Deployment
    runs-on: ubuntu-latest
    needs: finalize-deployment
    timeout-minutes: 10
    
    steps:
      - name: ğŸ” Verify HTTP redirect
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ” Verifying HTTP redirects to HTTPS..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$DOMAIN/health || echo "000")
          echo "   HTTP Status Code: $HTTP_STATUS"
          
          if [ "$HTTP_STATUS" = "301" ] || [ "$HTTP_STATUS" = "302" ]; then
            echo "âœ… HTTP correctly redirects to HTTPS"
          else
            echo "âš ï¸ HTTP returned status $HTTP_STATUS (expected 301 or 302)"
          fi
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: ğŸ”’ Verify HTTPS endpoint
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”’ Verifying HTTPS endpoint..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          HTTPS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://$DOMAIN/health || echo "000")
          RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" https://$DOMAIN/health || echo "0")
          echo "   HTTPS Status Code: $HTTPS_STATUS"
          echo "   Response Time: ${RESPONSE_TIME}s"
          
          if [ "$HTTPS_STATUS" = "200" ]; then
            echo "âœ… Deployment successful! HTTPS is working."
          else
            echo "âŒ HTTPS endpoint returned status $HTTPS_STATUS (expected 200)"
            exit 1
          fi
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: âœ… Verify health endpoint
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Verifying health endpoint response..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          RESPONSE=$(curl -s https://$DOMAIN/health)
          echo "   Response: $RESPONSE"
          
          if echo "$RESPONSE" | grep -q '"status":"UP"'; then
            echo "âœ… Health endpoint is responding correctly"
            echo "   Application status: UP"
          else
            echo "âš ï¸ Health endpoint response may be incorrect"
          fi
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: ğŸ” Verify Observability Stack
        run: |
          echo "::add-mask::$SSH_PASSWORD"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ” Verifying Observability Stack..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST << 'ENDSSH'
            cd /tmp/transaction-processor-api/docker
            
            echo "ğŸ“Š Checking container status..."
            docker compose ps
            
            echo ""
            echo "ğŸ” Verifying core services..."
            
            # Check PostgreSQL
            if docker ps --format '{{.Names}}' | grep -q 'transaction-db'; then
              if docker exec transaction-db pg_isready -U postgres > /dev/null 2>&1; then
                echo "âœ… PostgreSQL is running and healthy"
              else
                echo "âš ï¸ PostgreSQL container is running but not ready"
              fi
            else
              echo "âŒ PostgreSQL container is not running"
            fi
            
            # Check Redis
            if docker ps --format '{{.Names}}' | grep -q 'transaction-redis'; then
              if docker exec transaction-redis redis-cli ping > /dev/null 2>&1; then
                echo "âœ… Redis is running and healthy"
              else
                echo "âš ï¸ Redis container is running but not ready"
              fi
            else
              echo "âŒ Redis container is not running"
            fi
            
            # Check Application
            if docker ps --format '{{.Names}}' | grep -q 'transaction-api'; then
              echo "âœ… Application container is running"
              # Check if app is responding
              if docker exec transaction-api node -e "require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})" 2>/dev/null; then
                echo "âœ… Application health check passed"
              else
                echo "âš ï¸ Application container is running but health check failed"
              fi
            else
              echo "âŒ Application container is not running"
            fi
            
            echo ""
            echo "ğŸ“ˆ Checking Observability Stack (if enabled)..."
            
            # Check Prometheus (if observability profile is enabled)
            if docker ps --format '{{.Names}}' | grep -q 'transaction-prometheus'; then
              echo "âœ… Prometheus container is running"
              # Try to check Prometheus health
              if docker exec transaction-prometheus wget -q -O - http://localhost:9090/-/healthy > /dev/null 2>&1; then
                echo "âœ… Prometheus is healthy"
              else
                echo "âš ï¸ Prometheus container is running but health check failed"
              fi
            else
              echo "â„¹ï¸ Prometheus not running (observability profile not enabled)"
            fi
            
            # Check Grafana (if observability profile is enabled)
            if docker ps --format '{{.Names}}' | grep -q 'transaction-grafana'; then
              echo "âœ… Grafana container is running"
              # Try to check Grafana health
              if docker exec transaction-grafana wget -q -O - http://localhost:3000/api/health > /dev/null 2>&1; then
                echo "âœ… Grafana is healthy"
              else
                echo "âš ï¸ Grafana container is running but health check failed"
              fi
            else
              echo "â„¹ï¸ Grafana not running (observability profile not enabled)"
            fi
            
            # Check cAdvisor (if observability profile is enabled)
            if docker ps --format '{{.Names}}' | grep -q 'transaction-cadvisor'; then
              echo "âœ… cAdvisor container is running"
              # Try to check cAdvisor health
              if docker exec transaction-cadvisor wget -q -O - http://localhost:8080/healthz > /dev/null 2>&1; then
                echo "âœ… cAdvisor is healthy"
              else
                echo "âš ï¸ cAdvisor container is running but health check failed"
              fi
            else
              echo "â„¹ï¸ cAdvisor not running (observability profile not enabled)"
            fi
            
            echo ""
            echo "ğŸ“‹ Container resource usage:"
            docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}" | head -10 || true
            
            echo ""
            echo "ğŸ”’ Exposed ports check:"
            docker ps --format "table {{.Names}}\t{{.Ports}}" | grep -E "transaction-" || true
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          ENDSSH

      - name: ğŸ‰ Deployment Summary
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ‰ Deployment verification completed successfully!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Application URL: https://$DOMAIN"
          echo "âœ… Health Check: https://$DOMAIN/health"
          echo "âœ… API Documentation: https://$DOMAIN/api/docs"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
