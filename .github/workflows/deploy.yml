name: SSH Connection Test

on:
  push:
    branches:
      - main

jobs:
  deploy:
    name: Test SSH Connection
    runs-on: ubuntu-latest
    
    steps:
      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Test SSH connection
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $SSH_USER@$SSH_HOST "echo 'SSH OK'"

      - name: Clone repository on server
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
          REPO_URL: https://github.com/${{ github.repository }}.git
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $SSH_USER@$SSH_HOST << ENDSSH
            mkdir -p /tmp
            cd /tmp
            echo "Removing existing repository directory..."
            rm -rf transaction-processor-api
            echo "Cloning repository..."
            git clone $REPO_URL transaction-processor-api
            cd transaction-processor-api
            echo "Repository cloned successfully"
            ls -la
          ENDSSH

      - name: Backup PostgreSQL database
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME || 'transactions_db' }}
          DB_USER: ${{ secrets.DB_USER || 'postgres' }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD || 'postgres' }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $SSH_USER@$SSH_HOST << ENDSSH
            echo "Checking if PostgreSQL container is running..."
            if docker ps --format '{{.Names}}' | grep -q 'transaction-db'; then
              echo "PostgreSQL container is running. Creating backup..."
              
              BACKUP_DIR="/tmp/backups"
              mkdir -p \$BACKUP_DIR
              TIMESTAMP=\$(date +%Y%m%d_%H%M%S)
              BACKUP_FILE="\$BACKUP_DIR/\${DB_NAME}_\${TIMESTAMP}.sql"
              
              echo "Creating database dump..."
              docker exec transaction-db pg_dump -U \$DB_USER -d \$DB_NAME > \$BACKUP_FILE || {
                echo "Failed to create backup, but continuing..."
                exit 0
              }
              
              if [ -f \$BACKUP_FILE ] && [ -s \$BACKUP_FILE ]; then
                echo "✅ Backup created successfully: \$BACKUP_FILE"
                ls -lh \$BACKUP_FILE
                
                echo "Keeping only last 5 backups..."
                cd \$BACKUP_DIR
                ls -t \${DB_NAME}_*.sql | tail -n +6 | xargs rm -f || true
              else
                echo "⚠️ Backup file is empty or does not exist"
              fi
            else
              echo "PostgreSQL container is not running. Skipping backup."
            fi
          ENDSSH

      - name: Deploy with Docker Compose
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME || 'transactions_db' }}
          DB_USER: ${{ secrets.DB_USER || 'postgres' }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD || 'postgres' }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $SSH_USER@$SSH_HOST << ENDSSH
            cd /tmp/transaction-processor-api/docker
            
            echo "Configuring Docker BuildKit for cache..."
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1
            
            echo "Cleaning up unused containers and volumes (keeping build cache)..."
            docker container prune -f || true
            docker volume prune -f || true
            
            echo "Stopping existing containers and removing volumes..."
            docker compose down -v || true
            
            echo "Pulling base images (using cache)..."
            docker compose pull || true
            
            echo "Building containers with cache (only rebuild changed layers)..."
            docker compose build --pull
            
            echo "Starting containers..."
            docker compose up -d
            
            echo "Waiting for services to be healthy..."
            sleep 15
            
            echo "Waiting for PostgreSQL to be ready..."
            timeout=60
            elapsed=0
            while [ \$elapsed -lt \$timeout ]; do
              if docker exec transaction-db pg_isready -U \$DB_USER > /dev/null 2>&1; then
                echo "✅ PostgreSQL is ready"
                break
              fi
              echo "Waiting for PostgreSQL... (\$elapsed/\$timeout seconds)"
              sleep 2
              elapsed=\$((elapsed + 2))
            done
            
            echo "Restoring database backup if available..."
            BACKUP_DIR="/tmp/backups"
            LATEST_BACKUP=\$(ls -t \$BACKUP_DIR/\${DB_NAME}_*.sql 2>/dev/null | head -1)
            
            if [ -n "\$LATEST_BACKUP" ] && [ -f "\$LATEST_BACKUP" ]; then
              echo "Found backup: \$LATEST_BACKUP"
              echo "Restoring database..."
              
              docker exec -i transaction-db psql -U \$DB_USER -d postgres -c "DROP DATABASE IF EXISTS \$DB_NAME;" || true
              docker exec -i transaction-db psql -U \$DB_USER -d postgres -c "CREATE DATABASE \$DB_NAME;" || true
              
              cat \$LATEST_BACKUP | docker exec -i transaction-db psql -U \$DB_USER -d \$DB_NAME && {
                echo "✅ Database restored successfully from backup"
              } || {
                echo "⚠️ Failed to restore backup, database will be empty"
              }
            else
              echo "No backup found. Database will be created fresh."
            fi
            
            echo "Waiting for application container to be ready..."
            timeout=60
            elapsed=0
            while [ \$elapsed -lt \$timeout ]; do
              if docker ps --format '{{.Names}}' | grep -q 'transaction-api' && docker exec transaction-api node -e "console.log('OK')" > /dev/null 2>&1; then
                echo "✅ Application container is ready"
                break
              fi
              echo "Waiting for application... (\$elapsed/\$timeout seconds)"
              sleep 2
              elapsed=\$((elapsed + 2))
            done
            
            echo "Running database migrations..."
            docker exec transaction-api npm run migrate || echo "Migrations may have already been applied or container not ready"
            
            echo "Container status:"
            docker compose ps
            echo "Application logs:"
            docker compose logs --tail=30
          ENDSSH

      - name: Verify HTTPS deployment
        env:
          DOMAIN: ${{ secrets.DOMAIN }}
        run: |
          echo "Verifying HTTP redirects to HTTPS..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$DOMAIN/health)
          echo "HTTP status: $HTTP_STATUS"
          
          echo "Verifying HTTPS endpoint..."
          HTTPS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://$DOMAIN/health)
          echo "HTTPS status: $HTTPS_STATUS"
          
          if [ "$HTTPS_STATUS" = "200" ]; then
            echo "✅ Deployment successful! HTTPS is working."
          else
            echo "⚠️ HTTPS endpoint returned status $HTTPS_STATUS"
            exit 1
          fi
