name: Deploy to Production

on:
  push:
    branches:
      - main

env:
  SSH_HOST: ${{ secrets.SSH_HOST }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
  DB_NAME: ${{ secrets.DB_NAME || 'transactions_db' }}
  DB_USER: ${{ secrets.DB_USER || 'postgres' }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD || 'postgres' }}
  DOMAIN: ${{ secrets.DOMAIN }}

jobs:
  lint:
    name: Lint Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run lint
        run: npm run lint:check

  test-unit:
    name: Unit Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        env:
          NODE_ENV: test
        run: npm run test:unit

  test-integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install PostgreSQL client
        run: sudo apt-get update && sudo apt-get install -y postgresql-client

      - name: Create test database
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          until pg_isready -h localhost -p 5432 -U postgres; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done
          psql -h localhost -p 5432 -U postgres -c "CREATE DATABASE transactions_db_test;" || echo "Database may already exist"

      - name: Run database migrations
        env:
          NODE_ENV: test
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: postgres
          DB_PASSWORD: postgres
          DB_NAME: transactions_db_test
        run: npm run migrate

      - name: Run integration tests
        env:
          NODE_ENV: test
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: postgres
          DB_PASSWORD: postgres
          DB_NAME: transactions_db_test
          REDIS_HOST: localhost
          REDIS_PORT: 6379
        run: npm run test:integration

      - name: Drop test database
        if: always()
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          psql -h localhost -p 5432 -U postgres -c "DROP DATABASE IF EXISTS transactions_db_test;" || true
          echo "‚úÖ Test database destroyed"

  setup:
    name: Setup and Verify SSH Connection
    runs-on: ubuntu-latest
    needs: [lint, test-unit, test-integration]
    
    steps:
      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Test SSH connection
        run: |
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST "echo '‚úÖ SSH connection successful'"

  backup:
    name: Backup PostgreSQL Database
    runs-on: ubuntu-latest
    needs: setup
    
    steps:
      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Create database backup
        run: |
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST "DB_NAME='$DB_NAME' DB_USER='$DB_USER' bash -s" << 'ENDSSH'
            echo "üîç Checking if PostgreSQL container is running..."
            if docker ps --format '{{.Names}}' | grep -q 'transaction-db'; then
              echo "üì¶ PostgreSQL container is running. Creating backup..."
              
              BACKUP_DIR="/tmp/backups"
              mkdir -p "$BACKUP_DIR"
              TIMESTAMP=$(date +%Y%m%d_%H%M%S)
              BACKUP_FILE="$BACKUP_DIR/${DB_NAME}_${TIMESTAMP}.sql"
              
              echo "üíæ Creating database dump for database: $DB_NAME"
              docker exec transaction-db pg_dump -U "$DB_USER" -d "$DB_NAME" > "$BACKUP_FILE" || {
                echo "‚ö†Ô∏è Failed to create backup, but continuing..."
                exit 0
              }
              
              if [ -f "$BACKUP_FILE" ] && [ -s "$BACKUP_FILE" ]; then
                echo "‚úÖ Backup created successfully: $BACKUP_FILE"
                ls -lh "$BACKUP_FILE"
                
                echo "üßπ Keeping only last 5 backups..."
                cd "$BACKUP_DIR"
                ls -t "${DB_NAME}"_*.sql 2>/dev/null | tail -n +6 | xargs rm -f || true
              else
                echo "‚ö†Ô∏è Backup file is empty or does not exist"
              fi
            else
              echo "‚ÑπÔ∏è PostgreSQL container is not running. Skipping backup."
            fi
          ENDSSH

  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [setup, backup]
    
    steps:
      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Clone repository
        env:
          REPO_URL: https://github.com/${{ github.repository }}.git
        run: |
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST << ENDSSH
            mkdir -p /tmp
            cd /tmp
            echo "üóëÔ∏è Removing existing repository directory..."
            rm -rf transaction-processor-api
            echo "üì• Cloning repository..."
            git clone $REPO_URL transaction-processor-api
            cd transaction-processor-api
            echo "‚úÖ Repository cloned successfully"
            ls -la
          ENDSSH

      - name: Prepare application archive
        run: |
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST << 'ENDSSH'
            cd /tmp/transaction-processor-api
            
            echo "üì¶ Creating application archive (excluding unnecessary files)..."
            
            tar -czf app.tar.gz \
              --exclude='node_modules' \
              --exclude='dist' \
              --exclude='build' \
              --exclude='*.tsbuildinfo' \
              --exclude='test' \
              --exclude='coverage' \
              --exclude='*.spec.ts' \
              --exclude='*.test.ts' \
              --exclude='*.e2e-spec.ts' \
              --exclude='README.md' \
              --exclude='docs' \
              --exclude='*.md' \
              --exclude='.git' \
              --exclude='.gitignore' \
              --exclude='.gitattributes' \
              --exclude='.vscode' \
              --exclude='.idea' \
              --exclude='*.swp' \
              --exclude='*.swo' \
              --exclude='*~' \
              --exclude='.env' \
              --exclude='.env.local' \
              --exclude='.env.*.local' \
              --exclude='.DS_Store' \
              --exclude='Thumbs.db' \
              --exclude='logs' \
              --exclude='*.log' \
              --exclude='.eslintcache' \
              --exclude='docker' \
              --exclude='.dockerignore' \
              --exclude='docker-compose.yml' \
              src/ \
              package.json \
              package-lock.json \
              tsconfig.json \
              nest-cli.json \
              migrations/ \
              eslint.config.mjs \
              .prettierrc \
              tsconfig.build.json || {
              echo "‚ö†Ô∏è Failed to create archive, falling back to direct copy"
              exit 0
            }
            
            echo "‚úÖ Archive created successfully"
            ls -lh app.tar.gz
          ENDSSH

      - name: Build and start containers
        run: |
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST "DB_NAME='$DB_NAME' DB_USER='$DB_USER' DB_PASSWORD='$DB_PASSWORD' bash -s" << 'ENDSSH'
            cd /tmp/transaction-processor-api/docker
            
            echo "‚öôÔ∏è Configuring Docker BuildKit for cache..."
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1
            
            echo "üßπ Cleaning up unused containers and volumes (keeping build cache)..."
            docker container prune -f || true
            docker volume prune -f || true
            
            echo "üõë Stopping existing containers and removing volumes..."
            docker compose down -v || true
            
            echo "üì• Pulling base images (using cache)..."
            docker compose pull || true
            
            echo "üî® Building containers with cache (only rebuild changed layers)..."
            docker compose build --pull
            
            echo "üßπ Cleaning up archive after build..."
            cd /tmp/transaction-processor-api
            rm -f app.tar.gz || true
            
            echo "üöÄ Starting containers..."
            docker compose up -d
            
            echo "‚è≥ Waiting for services to be healthy..."
            sleep 15
          ENDSSH

      - name: Wait for PostgreSQL
        run: |
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST "DB_USER='$DB_USER' bash -s" << 'ENDSSH'
            echo "‚è≥ Waiting for PostgreSQL to be ready..."
            timeout=60
            elapsed=0
            while [ $elapsed -lt $timeout ]; do
              if docker exec transaction-db pg_isready -U "$DB_USER" > /dev/null 2>&1; then
                echo "‚úÖ PostgreSQL is ready"
                break
              fi
              echo "Waiting for PostgreSQL... ($elapsed/$timeout seconds)"
              sleep 2
              elapsed=$((elapsed + 2))
            done
          ENDSSH

      - name: Restore database backup
        run: |
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST "DB_NAME='$DB_NAME' DB_USER='$DB_USER' bash -s" << 'ENDSSH'
            echo "üì• Restoring database backup if available..."
            BACKUP_DIR="/tmp/backups"
            LATEST_BACKUP=$(ls -t "$BACKUP_DIR/${DB_NAME}"_*.sql 2>/dev/null | head -1)
            
            if [ -n "$LATEST_BACKUP" ] && [ -f "$LATEST_BACKUP" ]; then
              echo "üì¶ Found backup: $LATEST_BACKUP"
              echo "üîÑ Restoring database..."
              
              docker exec -i transaction-db psql -U "$DB_USER" -d postgres -c "DROP DATABASE IF EXISTS $DB_NAME;" || true
              docker exec -i transaction-db psql -U "$DB_USER" -d postgres -c "CREATE DATABASE $DB_NAME;" || true
              
              cat "$LATEST_BACKUP" | docker exec -i transaction-db psql -U "$DB_USER" -d "$DB_NAME" && {
                echo "‚úÖ Database restored successfully from backup"
              } || {
                echo "‚ö†Ô∏è Failed to restore backup, database will be empty"
              }
            else
              echo "‚ÑπÔ∏è No backup found. Database will be created fresh."
            fi
          ENDSSH

      - name: Wait for application
        run: |
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST << 'ENDSSH'
            echo "‚è≥ Waiting for application container to be ready..."
            timeout=60
            elapsed=0
            while [ $elapsed -lt $timeout ]; do
              if docker ps --format '{{.Names}}' | grep -q 'transaction-api' && \
                 docker exec transaction-api node -e "console.log('OK')" > /dev/null 2>&1; then
                echo "‚úÖ Application container is ready"
                break
              fi
              echo "Waiting for application... ($elapsed/$timeout seconds)"
              sleep 2
              elapsed=$((elapsed + 2))
            done
          ENDSSH

      - name: Run database migrations
        run: |
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST << 'ENDSSH'
            echo "üîÑ Running database migrations..."
            docker exec transaction-api npm run migrate || \
              echo "‚ÑπÔ∏è Migrations may have already been applied or container not ready"
          ENDSSH

      - name: Show deployment status
        run: |
          sshpass -p "$SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            $SSH_USER@$SSH_HOST << 'ENDSSH'
            cd /tmp/transaction-processor-api/docker
            echo "üìä Container status:"
            docker compose ps
            echo ""
            echo "üìã Application logs (last 30 lines):"
            docker compose logs --tail=30
          ENDSSH

  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: deploy
    
    steps:
      - name: Verify HTTP redirects to HTTPS
        run: |
          echo "üîç Verifying HTTP redirects to HTTPS..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$DOMAIN/health)
          echo "HTTP status: $HTTP_STATUS"
          
          if [ "$HTTP_STATUS" = "301" ] || [ "$HTTP_STATUS" = "302" ]; then
            echo "‚úÖ HTTP correctly redirects to HTTPS"
          else
            echo "‚ö†Ô∏è HTTP returned status $HTTP_STATUS (expected 301 or 302)"
          fi

      - name: Verify HTTPS endpoint
        run: |
          echo "üîç Verifying HTTPS endpoint..."
          HTTPS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://$DOMAIN/health)
          echo "HTTPS status: $HTTPS_STATUS"
          
          if [ "$HTTPS_STATUS" = "200" ]; then
            echo "‚úÖ Deployment successful! HTTPS is working."
          else
            echo "‚ùå HTTPS endpoint returned status $HTTPS_STATUS (expected 200)"
            exit 1
          fi

      - name: Verify health endpoint response
        run: |
          echo "üîç Verifying health endpoint response..."
          RESPONSE=$(curl -s https://$DOMAIN/health)
          echo "Response: $RESPONSE"
          
          if echo "$RESPONSE" | grep -q '"status":"UP"'; then
            echo "‚úÖ Health endpoint is responding correctly"
          else
            echo "‚ö†Ô∏è Health endpoint response may be incorrect"
          fi
